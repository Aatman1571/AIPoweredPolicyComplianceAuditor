Security Engineering: A Guide to Building Dependable Distributed Systems
51CHAPTER4Access Control
Going all the way back to early time-sharing systems, we systems people regarded theusers, and any code they wrote, as the mortal enemies of us and each other. We were likethe police force in a violent slum.—ROGER NEEDHAMMicrosoft could have incorporated effective security measures as standard, but goodsense prevailed. Security systems have a nasty habit of backfiring, and there is no doubtthey would cause enormous problems.—RICK MAYBURY4.1 IntroductionAccess control is the traditional center of gravity of computer security. It is where se-curity engineering meets computer science. Its function is to control which principals(persons, processes, machines, . . .) have access to which resources in the sys-tem—which files they can read, which programs they can execute, how they share datawith other principals, and so on.NOTEThis chapter necessarily assumes more computer science background than previouschapters, but I try to keep it to a minimum.
Chapter 4: Access Controls
52
Figure 4.1 Access controls at different levels in a system.Access control works at a number of levels, as shown in Figure 4.1, and described inthe following:1.The access control mechanisms, which the user sees at the application level,may express a very rich and complex security policy. A modern online busi-ness could assign staff to one of dozens of different roles, each of which couldinitiate some subset of several hundred possible transactions in the system.Some of these (such as credit card transactions with customers) might requireonline authorization from a third party while others (such as refunds) mightrequire dual control.2.The applications may be written on top of middleware, such as a databasemanagement system or bookkeeping package, which enforces a number ofprotection properties. For example, bookkeeping software may ensure that atransaction that debits one ledger for a certain amount must credit anotherledger for the same amount.3.The middleware will use facilities provided by the underlying operating sys-tem. As this constructs resources such as files and communications ports fromlower-level components, it acquires the responsibility for providing ways tocontrol access to them.4.Finally, the operating system access controls will usually rely on hardwarefeatures provided by the processor or by associated memory managementhardware. These control which memory addresses a given process can access.As we work up from the hardware through the operating system and middleware tothe application layer, the controls become progressively more complex and less reli-able. Most actual computer frauds involve staff accidentally discovering features of theapplication code that they can exploit in an opportunistic way, or just abusing featuresof the application that they were trusted not to. But in this chapter, we will focus on thefundamentals: access control at the hardware and operating system level. (Application-level controls aren’t different in principle, but I leave detailed discussion to Part 2 ofthis book.)As with the other building blocks discussed so far, access control makes sense onlyin the context of a protection goal, typically expressed as a security policy. This putsus at a slight disadvantage when discussing PCs running single-user operating systemssuch as DOS and Win95/98, which have no overt security policy: any process canmodify any data. People do have implicit protection goals, though; you don’t expect a
Security Engineering: A Guide to Building Dependable Distributed Systems
53shrink-wrap program to trash your hard disk. So an explicit security policy is a goodidea, especially when products support some features that appear to provide protection,such as login IDs.I mention one protection technique—sandboxing—later, but leave off a substantialdiscussion of viruses and the like to Section 18.4. In what follows, the focus will be onprotection mechanisms for systems that support the isolation of multiple processes. Idiscuss operating system mechanisms first, as it is their requirements that usually drivehardware protection system design.4.2 Operating System Access ControlsThe access controls provided with an operating system typically authenticate principalsusing some mechanism such as passwords or Kerberos, then mediate their access tofiles, communications ports, and other system resources.Their effect can often be modelled by a matrix of access permissions, with columnsfor files and rows for users. We’ll write r for permission to read, w for permission towrite, x for permission to execute a program, and (–) for no access at all, as shown inFigure 4.2.In this simplified example, Sam is the system administrator, and has universal access(except to the audit trail, which even he should only be able to read). Alice, the man-ager, needs to execute the operating system and application, but only through the ap-proved interfaces—she mustn’t have the ability to tamper with them. She also needs toread and write the data. Bob, the auditor, can read everything.
Figure 4.2 Naive access control matrix.
Figure 4.3 Example access control matrix for bookkeeping.This is often enough, but in the specific case of a bookkeeping system, it’s not quitewhat we need. We want to ensure that transactions are well formed—that each debit ismatched by a credit somewhere else—so we would not want Alice to have uninhibitedwrite access to the account file. We would also prefer that Sam didn’t have this access;so that all write access to the accounting data file was via the accounting program. The
Chapter 4: Access Controls
54access permissions might now look like those shown in Figure 4.3. (There is still anindirect vulnerability in that Sam could overwrite the accounts program with an unau-thorised one of his own devising, but we’ll leave off discussing that till Chapter 9.)Another way of expressing a policy of this type would be with access triples of user,program, file. In the general case, our concern isn’t with a program as much as a pro-tection domain, which is a set of processes or threads that share access to the same re-sources (though at any given time they might have different files open or differentscheduling priorities).Access control matrices (whether in two or three dimensions) can be used to imple-ment protection mechanisms, as well as just model them. But they do not scale well.For instance, a bank with 50,000 staff and 300 applications would have an access con-trol matrix of 15 million entries. This is inconveniently large. It might not only imposea performance problem but also be vulnerable to administrators’ mistakes. We willusually need a more compact way of storing and managing this information. The twomain ways of doing this are to use groups or roles to manage the privileges of largesets of users simultaneously, or to store the access control matrix either by columns(access control lists) or rows (capabilities, sometimes known as “tickets”) or certifi-cates [662, 804].4.2.1 Groups and RolesWhen we look at large organizations, we usually find that most staff fit into one orother of a small number of categories. A bank might have 40 or 50 such categories:teller, chief teller, branch accountant, branch manager, and so on. The remainder (suchas the security manager, and chief foreign exchange dealer,...), who need to have theiraccess rights defined individually, may amount to only a few dozen people.So we want a small number of predefined groups, or functional roles, to which staffcan be assigned. Some people use the words group and role interchangeably, and withmany systems they are; but the more careful definition is that a group is a list of prin-cipals, while a role is a fixed set of access permissions that one or more principals mayassume for a period of time using some defined procedure. The classic example of arole is the officer of the watch on a ship. There is exactly one watchkeeper at any onetime, and there is a formal procedure whereby one officer relieves another when thewatch changes. In fact, in most military applications, it’s the role that matters ratherthan the individual.Groups and roles can be combined. The officers of the watch of all ships currently atsea is a group of roles. In banking, the manager of the Cambridge branch might havehis or her privileges expressed by membership of the group manager and assumptionof the role acting manager of Cambridge branch. The group manager might express arank in the organization (and perhaps even a salary scale) while the role acting man-ager might include an assistant accountant standing in while the manager, deputy man-ager, and branch accountant are all sick.Whether we need to be careful about this distinction is a matter for the application.In a warship, we want even an able seaman to be allowed to stand watch if all the offi-cers have been killed. In a bank, we might have a policy that “transfers over $10 mil-lion must be approved by two staff, one with the rank of manager and one with therank of assistant accountant.” In the event of sickness, the assistant accountant actingas manager would have to get the regional head office to provide the second signatureon a large transfer.
Security Engineering: A Guide to Building Dependable Distributed Systems
55Until recently, some support for groups and roles existed but was not very widelyused. Developers either implemented this kind of functionality in their applicationcode, or as custom middleware (in the 1980s, I worked on two bank projects wheregroup support was hand-coded as extensions to the mainframe operating system). Re-cently, Windows 2000 (Win2K) has been launched with very extensive support forgroups, while academic researchers have started working on role-based access control(RBAC), which I discuss further in Chapter 7. We will have to wait and see whethereither of these has a major effect on application development practices.
Figure 4.4 Access control list (ACL).4.2.2 Access Control ListsAnother way of simplifying access rights management is to store the access controlmatrix a column at a time, along with the resource to which the column refers. This iscalled an access control list, or ACL. In the first of the examples, the ACL for file 3(the account file) might look as shown in Figure 4.4.ACLs have a number of advantages and disadvantages as a means of managing secu-rity state. These can be divided into general properties of ACLs and specific propertiesof particular implementations.ACLs are widely used in environments where users manage their own file security,such as the Unix systems common in universities and science labs. Where access con-trol policy is set centrally, they are suited to environments where protection is data-oriented; they are less suited where the user population is large and constantly chang-ing, or where users want to be able to delegate their authority to run a particular pro-gram to another user for some set period of time. ACLs are simple to implement, butare not efficient as a means of doing security checking at runtime, as the typical oper-ating system knows which user is running a particular program, rather than which filesit has been authorized to access since it was invoked. The operating system must eithercheck the ACL at each file access or keep track of the active access rights in someother way.Finally, distributing the access rules into ACLs can make it tedious to find all thefiles to which a user has access. Revoking the access of an employee who has just beenfired, for example, will usually have to be done by cancelling their password or otherauthentication mechanism. It may also be tedious to run systemwide checks, such asverifying that no files have been left world-writable. This could involve checkingACLs on millions of user files.Let’s look at two important examples of ACLs: their implementation in Unix andNT.
Chapter 4: Access Controls
564.2.3 Unix Operating System SecurityIn Unix (and its popular variant Linux), files are not allowed to have arbitrary accesscontrol lists, but simply rwx attributes for the resource owner, the group, and the world.These attributes allow the file to be read, written, and executed. The access control listas normally displayed has a flag to show whether the file is a directory; then flags r, w,and x for owner, group, and world respectively; it then has the owner’s name and thegroup name. A directory with all flags set would have the ACL:drwxrwxrwx Alice AccountsIn the first example in Figure 4.4, the ACL of file 3 would be:-rw-r—–---Alice AccountsThis records that the file is not a directory; the file owner can read and write it;group members can read it but not write it; nongroup members have no access at all;the file owner is Alice; and the group is Accounts.In Unix, the program that gets control when the machine is booted (the operatingsystem kernel) runs as the supervisor, and has unrestricted access to the whole ma-chine. All other programs run as users, and have their access mediated by the supervi-sor. Access decisions are made on the basis of the userid associated with the program.However if this is zero (root), then the access control decision is “yes.” So root can dowhat it likes—access any file, become any user, or whatever. What’s more, there arecertain things that only root can do, such as starting certain communication processes.The root userid is typically made available to the system administrator.This means that (with most flavors of Unix) the system administrator can do any-thing, so we have difficulty implementing an audit trail as a file that he cannot modify.This not only means that, in our example, Sam could tinker with the accounts, and havedifficulty defending himself if he were falsely accused of tinkering, but that a hackerwho managed to become the system administrator could remove all evidence of hisintrusion. A common defense is to send the system log to a printer in a locked roomor—if the volumes of data are too great—to another machine that is administered bysomebody else.The Berkeley distributions, including FreeBSD, go some way toward fixing theproblem. Files can be set to be append-only, immutable or undeletable for user, systemor both. When set by a user at a sufficient security level during the boot process, theycannot be overridden or removed later, even by root. Various military variants go toeven greater trouble to allow separation of duty. However, the simplest and mostcommon way to protect logs against root compromise is to keep them on a separateserver.Second, ACLs contain only the names of users, not of programs, so there is nostraightforward way to implement access triples of (user, program, file). Instead, Unixprovides an indirect method: the suid and sgid file attributes.The owner of a program can mark it as suid. This enables it to run with the privilegeof its owner rather than the privilege of the user who has invoked it; sgid does thesame for groups. Thus, in order to achieve the functionality needed by Figure 4.3, wecould create a user “account-package” to own file 2 (the accounts package), make thefile suid, and place it in a directory to which Alice has access. This special user couldthen be given the access control attributes we want for the accounts program.One way of looking at this is that an access control problem that is naturally mod-elled in three dimensions—the triples (user, program, data)—is being implementedusing two-dimensional mechanisms. These mechanisms are much less intuitive than
Security Engineering: A Guide to Building Dependable Distributed Systems
57triples, and people make many mistakes implementing them. Programmers are oftenlazy or facing tight deadlines; so they just make the application suid root, and it can doanything.This practice leads to some rather shocking security holes. The responsibility formaking access control decisions is moved from the operating system environment tothe program, and most programmers are insufficiently experienced and careful to checkeverything that they should. In particular, the person invoking a suid root programcontrols its environment and can often manipulate this to cause protection failures.Third, ACLs are not very good at expressing changing state. Managing stateful ac-cess rules, such as dual control, becomes difficult; one either has to do it at the appli-cation level or use suid/sgid again. Also, it’s hard to track the files that a user mighthave open (as you typically want to do when revoking their rights on a system).Fourth, the Unix ACL names only one user. Older versions allow a process to holdonly one group ID at a time and force it to use a privileged program to access othergroups; newer Unix systems put a process in all groups that the user is in. This is stillmuch less expressive than one might like. In theory, the ACL and su mechanisms canoften be used to achieve the desired effect. In practice, programmers are often too lazyto figure out how to do this, and so design their code to require much more privilegethan it really ought to.4.2.4 Windows NTAnother important operating system whose protection is largely based on access con-trol lists is Windows NT. The current version of NT (version 5, or Win2K) is fairlycomplex, so it’s helpful to trace its antecedents. (This can also be useful if you have tohelp manage upgrades from NT4 to Win2K).NT4 protection is very much like Unix, and appears to be inspired by it, so it’s sim-pler to describe the main innovations.First, rather than just read, write, and execute, there are separate attributes for takeownership, change permissions, and delete, which means that more flexible delegationcan be supported. These attributes apply to groups as well as users, and group permis-sions allow you to achieve much the same effect as sgid programs in Unix. Attributesare not simply on or off, as in Unix, but have multiple values: you can set Access-Denied, AccessAllowed, or SystemAudit. These are parsed in that order. If an Access-Denied is encountered in an ACL for the relevant user or group, then no access ispermitted, regardless of any conflicting AccessAllowed flags.A benefit of the richer syntax is that you can arrange matters so that much less thanfull administrator privileges are required for everyday configuration tasks, such as in-stalling printers. (This is rarely done, though.)Second, users and resources can be partitioned into domains with distinct adminis-trators, and trust can be inherited between domains in one direction or both. In a typi-cal large company, you might put all the users into a domain administered by thepersonnel department, while resources such as servers and printers could be in resourcedomains under departmental control; individual workstations might even be adminis-tered by their users. Things would be arranged so that the departmental resource do-mains trust the user domain, but not vice versa—so a corrupt or careless departmentaladministrator couldn’t do much damage outside his or her own domain. The individualworkstations would in turn trust the department (but not vice versa) so that users couldperform tasks that require local privilege (installing many software packages requires
Chapter 4: Access Controls
58this). Administrators are all-powerful (so you can’t create truly tamper-resistant audittrails without using write-once storage devices), but the damage they can do can belimited by suitable organization. The data structure used to manage all this, and hidethe ACL details from the user interface, is called the Registry.Problems with designing an NT architecture in very large organizations includenaming issues (which we’ll explore later), the way domains scale as the number ofprincipals increases (badly), and the restriction that a user in another domain can’t bean administrator (which can cause complex interactions between local and globalgroups).One peculiarity of NT is that everyone is a principal, not a default or an absence ofcontrol, so remove everyone means just prevent a file being generally accessible. Aresource can be locked quickly by setting everyone to have no access. This brings usnaturally to the subject of capabilities.4.2.5 CapabilitiesThe next way to manage the access control matrix is to store it by rows. These arecalled capabilities. In the example in Figure 4.2, Bob’s capabilities would be as shownin Figure 4.5.The strengths and weaknesses of capabilities are more or less the opposite of ACLs.Runtime security checking is more efficient, and we can do delegation without muchdifficulty: Bob could create a certificate saying “Here is my capability, and I herebydelegate to David the right to read file 4 from 9 A.M. to 1 P.M.; signed Bob.” On theother hand, changing a file’s status can suddenly become more tricky, as it can be dif-ficult to find out which users have access. This can be tiresome when investigating anincident or preparing evidence of a crime.There were a number of experimental implementations in the 1970s, which wererather like file passwords; users would get hard-to-guess bitstrings for the various read,write, and other capabilities to which they were entitled. It was found that such an ar-rangement could give very comprehensive protection [804]. It was not untypical to findthat almost all of an operating system could run in user mode, rather than as supervi-sor, so operating system bugs were not security critical. (In fact, many operating sys-tem bugs caused security violations, which made debugging the operating system mucheasier.)The IBM AS/400 series systems employed capability-based protection, and enjoyedsome commercial success. Now capabilities are making a comeback in the form ofpublic key certificates. We’ll discuss the mechanisms of public key cryptography inChapter 5, and give more concrete details of certificate-based systems, such asSSL/TLS, in Section 19.5. For now, think of a public key certificate as a credentialsigned by some authority, which declares that the holder of a certain cryptographic keyis a certain person, a member of some group, or the holder of some privilege.
Figure 4.5 A capability.
Security Engineering: A Guide to Building Dependable Distributed Systems
59As an example of where certificate-based capabilities can be useful, consider a hos-pital. If we implemented a rule stating “a nurse will have access to all the patients whoare on her ward, or who have been there in the last 90 days,” naively, each access con-trol decision in the patient record system would require several references to adminis-trative systems, to find out which nurses and which patients were on which ward,when. This means that a failure of the administrative systems can now affect patientsafety much more directly than was previously the case, which is a clearly bad thing.Matters can be much simplified by giving nurses certificates that entitle them to accessthe files associated with their current ward. Such a system is starting to be fielded atour university hospital.One point to bear in mind is that as public key certificates are often considered to be“crypto” rather than “access control,” their implications for access control policies andarchitectures are not always thought through. The lessons that could have been learnedfrom the capability systems of the 1970s are generally having to be rediscovered (thehard way). In general, the boundary between crypto and access control is a fault linewhere things can easily go wrong. The experts often come from different backgrounds,and the products from different suppliers.4.2.6 Added Features in Windows 2000A number of systems, from mainframe access control products to research systems,have combined ACLs and capabilities in an attempt to get the best of both worlds. Butthe most important application of capabilities is in Win2K.Win2K adds capabilities in two ways that can override or complement the ACLs ofNT4. First, users or groups can be either whitelisted or blacklisted by means of pro-files. (Some limited blacklisting was also possible in NT4.) Security policy is set bygroups rather than for the system as a whole. Groups are intended to be the primarymethod for centralized configuration management and control (group policy overridesindividual profiles). Group policy can be associated with sites, domains, or organiza-tional units, so it can start to tackle some of the real complexity problems with naming.Policies can be created using standard tools or by custom-coding (Microsoft has an-nounced that group policy data will be exposed in a standard schema). Groups are de-fined in the Active Directory, an object-oriented database which organizes users,groups, machines, and organizational units within a domain in a hierarchical name-space, indexing them so they can searched for on any attribute. There are also finer-grained access control lists on individual resources.As already mentioned, Win2K uses Kerberos as its main means of authenticating us-ers across networks.1 This is encapsulated behind the Security Support Provider Inter-face (SSPI), which enables administrators to plug in other authentication services.                                                            1In fact, it’s a proprietary variant, with changes to the ticket format, which preventWin2K clients from working with existing Unix Kerberos infrastructures. The documenta-tion for the changes is released on condition that it not be used to make compatible imple-mentations. Microsoft’s goal is to get everyone to install Win2K Kerberos servers. This hascaused an outcry in the open systems community [76].
Chapter 4: Access Controls
60This brings us to the second way in which capabilities insinuate their way intoWin2K: in many applications, people are likely to use the public key protocolSSL/TLS, which is widely used on the Web, and which is based on public key certifi-cates. The management of these certificates can provide another, capability-oriented,layer of access control outside the purview of the Active Directory. (I discuss SSL/TLSin Section 19.5.)There are various backward-compatibility issues. For example, high-security con-figurations of Win2K with full cryptographic authentication can’t interwork with NT4systems. This is because an active directory can exist alongside the registry of NT4,but the registry can’t read it. So the deployment of Win2K’s high-security features inlarge organizations is likely to be delayed until all the important applications have mi-grated.Win2K provides a richer and more flexible set of access control tools than any sys-tem previously sold in mass markets. It does still have design limitations. Implement-ing roles whose requirements differ from those of groups could be tricky in someapplications; SSL certificates are the obvious way to do this, but would require an ex-ternal management infrastructure. Second, Windows is still (in most of its incarna-tions) a single-user operating system, in the sense that only one person can operate aPC at a time. Thus, if I want to run an unprivileged, sacrificial user on my PC for ac-cessing untrustworthy Web sites that might contain malicious code, I have to log offand log on again, or use other techniques that are so inconvenient that few users willbother. So users still do not get the benefit from the operating system’s protectionproperties that they might wish when browsing the Web.4.2.7 GranularityA practical problem with all current flavors of access control system is granularity. Asthe operating system works with files, this will usually be the smallest object withwhich its access control mechanisms can deal. So it will be application-level mecha-nisms that, for example, ensure that a bank customer at a cash machine can see his orher own balance but not anybody else’s.But it goes deeper than that. Many applications are built using database tools thatgive rise to some problems that are much the same whether running DB2 on MVS orOracle on Unix. All the application data is bundled together in one file, and the oper-ating system must either grant or deny a user access to the lot. So, if you developedyour branch accounting system under a database product, then you’ll probably have tomanage one access mechanism at the operating system level and another at the data-base or application level. Many real problems result. For example, the administrationof the operating system and the database system may be performed by different de-partments, which do not talk to each other; and often user pressure drives IT depart-ments to put in crude hacks that make the various access control systems seem to workas one, but that open up serious holes.Another granularity problem is single sign-on. Despite the best efforts of computermanagers, most large companies accumulate systems of many different architectures,so users get more and more logons to different systems; consequently, the cost of ad-ministering them escalates. Many organizations want to give each employee a singlelogon to all the machines on the network. A crude solution is to endow their PCs with amenu of hosts to which a logon is allowed, and hide the necessary userids and pass-words in scripts. More sophisticated solutions may involve a single security server
Security Engineering: A Guide to Building Dependable Distributed Systems
61through which all logons must pass, or a smartcard to do multiple authentication proto-cols for different systems. Such solutions are hard to engineer properly. Whicheverroute one takes, the security of the best system can easily be reduced to that of theworst.4.2.8 Sandboxing and Proof-Carrying CodeAnother way of implementing access control is a software sandbox. Here users want torun some code that they have downloaded from the Web as an applet. Their concern isthat the applet might do something nasty, such as taking a list of all their files andmailing it off to a software marketing company.The designers of Java tackle this problem by providing a “sandbox” for suchcode—a restricted environment in which it has no access to the local hard disk (or atmost only temporary access to a restricted directory), and is only allowed to communi-cate with the host it came from. These security objectives are met by having the codeexecuted by an interpreter—the Java Virtual Machine (JVM)—which has only limitedaccess rights [346]. Java is also used on smartcards, but (in current implementations atleast) the JVM is, in effect, a compiler external to the card, which raises the issue ofhow the code it outputs can be gotten to the card in a trustworthy manner.An alternative is proof-carrying code. Here, code to be executed must carry with it aproof that it doesn’t do anything that contravenes the local security policy. This way,rather than using an interpreter with the resulting speed penalty, one merely has to trusta short program that checks the proofs supplied by downloaded programs before al-lowing them to be executed. The huge overhead of a JVM is not necessary [585].Both of these are less general alternatives to an architecture that supports proper su-pervisor-level confinement.4.2.9 Object Request BrokersThere has been much interest of late in object-oriented software development, as it hasthe potential to cut the cost of software maintenance. An object consists of code anddata bundled together, accessible only through specified externally visible methods.This also gives the potential for much more powerful and flexible access control. Muchresearch is underway with the goal of producing a uniform security interface that isindependent of the underlying operating system and hardware.The idea is to base security functions on the object request broker, or ORB, a soft-ware component that mediates communications between objects. Many research effortsfocus on the Common Object Request Broker Architecture (CORBA), which is an at-tempt at an industry standard for object-oriented systems. The most important aspect ofthis is that an ORB is a means of controlling calls that are made across protection do-mains. This approach appears promising but is still under development. (A book onCORBA security is [112].)
Chapter 4: Access Controls
624.3 Hardware ProtectionMost access control systems set out not just to control what users can do, but to limitwhat programs can do as well. In most systems, users can either write programs ordownload and install them. Programs may be buggy or even malicious.Preventing one process from interfering with another is the protection problem. Theconfinement problem is usually defined as that of preventing programs communicatingoutward other than through authorized channels. This comes in several flavors. Thegoal may be to prevent active interference, such as memory overwriting, and to stopone process reading another’s memory directly. This is what commercial operatingsystems set out to do. Military systems may also try to protect metadata—data aboutother data, subjects, or processes—so that, for example, a user can’t find out whichother users are logged on to the system or which processes they are running. In someapplications, such as processing census data, confinement means allowing a program toread data but not release anything about it other than the results of certain constrainedqueries; this is covered further in Chapter 7.Unless one uses sandboxing techniques (which are too restrictive for general pro-gramming environments), solving the confinement problem on a single processormeans, at the very least, having a mechanism that will stop one program from over-writing another’s code or data. There may be areas of memory that are shared in orderto allow interprocess communication; but programs must be protected from accidentalor deliberate modification, and they must have access to memory that is similarly pro-tected.This usually means that hardware access control must be integrated with the proces-sor’s memory management functions. A typical mechanism is segment addressing.Memory is addressed by two registers, a segment register that points to a segment ofmemory, and another address register that points to a location within that segment. Thesegment registers are controlled by the operating system, and often by a special com-ponent of it called the reference monitor, which links the access control mechanismswith the hardware.The actual implementation has become more complex as the processors themselveshave. Early IBM mainframes had a two-state CPU: the machine was either in author-ized state or it was not. In the latter case, the program was restricted to a memory seg-ment allocated by the operating system. In the former, it could alter the segmentregisters at will. An authorized program was one that was loaded from an authorizedlibrary.Any desired access control policy can be implemented on top of this, given suitableauthorized libraries, but this is not always efficient; and system security depends onkeeping bad code (whether malicious or buggy) out of the authorized libraries. Laterprocessors have offered more complex hardware mechanisms. Multics, an operatingsystem developed at MIT in the 1960s and that inspired the development of Unix, in-troduced rings of protection which express differing levels of privilege: ring 0 pro-grams had complete access to disk, supervisor states ran in ring 2, and user code atvarious less privileged levels [687]. Its features have to some extent been adopted inmore recent processors, such as the Intel main processor line from the 80286 onward.
Security Engineering: A Guide to Building Dependable Distributed Systems
63There are a number of general problems with interfacing hardware and software se-curity mechanisms. For example, it often happens that a less privileged process such asapplication code needs to invoke a more privileged process such as a device driver.The mechanisms for doing this need to be designed with some care, or security bugscan be expected. The IBM mainframe operating system MVS, for example, had a bugin which a program that executed a normal and an authorized task concurrently couldmake the former authorized too [493]. Also, performance may depend quite drasticallyon whether routines at different privilege levels are called by reference or by value[687].4.3.1 Intel 80_86/Pentium ProcessorsEarly Intel processors, such as the 8088/8086 used in early PCs, had no distinctionbetween system and user mode, and thus no protection at all—any running programcontrolled the whole machine. The 80286 added protected segment addressing andrings, so for the first time it could run proper operating systems. The 80386 had built-in virtual memory and large enough memory segments (4 Gb) that they could be ig-nored and the machine treated as a 32-bit flat-address machine. The 486 and Pentiumseries chips added more performance (caches, out-of-order execution and MMX). ThePentium 3 finally added a new security feature—a processor serial number. Thiscaused such a storm of protest, driven by privacy advocates who feared it could beused for all sorts of “big brother” purposes, that it will apparently be discontinued infuture Pentium products. (But identifying a PC will remain easy, as there are manyother serial numbers in disk controllers and other components that a snooping programcan read.)The rings of protection are supported by a number of mechanisms. The currentprivilege level can be changed only by a process in ring 0 (the kernel). Procedures can-not access objects in lower-level rings directly; but there are gates that allow executionof code at a different privilege level and that manage the supporting infrastructure,such as multiple stack segments for different privilege levels and exception handling.(For more details, see [404].)The Pentium’s successor architecture, the IA-64, was not yet available at the time ofwriting. According to the advance publicity, its memory management is based on di-viding the virtual address space of each process into several regions whose identifiersspecify the set of translations belonging to a process, and provide a unique intermedi-ate virtual address. This is to help avoid thrashing problems in caches and in transla-tion lookaside buffers. Regions also provide efficient shared areas between processes.Like the Pentium, the IA-64 has four protection rings [382].4.3.2 ARM ProcessorsThe ARM is the 32-bit processor core most commonly licensed to third-party vendorsof embedded systems. The original ARM (which stood for Acorn Rise Machine) wasthe first commercial RISC design. Its modern day successors are important becausethey are incorporated in all sorts of security-sensitive applications from mobile phonesto the Capstone chips used by the U.S. government to protect secret data. A fast multi-ply-and-accumulate instruction and low-power consumption make the ARM very at-tractive for embedded applications doing public key cryptography and/or signalprocessing. (The standard reference is [325].)
Chapter 4: Access Controls
64The ARM is licensed as a processor core, which chip designers can include in theirproducts, plus a number of optional add-ons. The basic core contains separate banks ofregisters for user and system processes, plus a software-interrupt mechanism that putsthe processor in supervisor mode and transfers control to a process at a fixed address.The core contains no memory management, so ARM-based designs can have theirhardware protection extensively customized. A system control coprocessor is availableto help with this. It can support domains of processes that have similar access rights(and thus share the same translation tables) but that retain some protection from eachother. This enables fast context switching. Standard product ARM CPU chips, from themodel 600 onward, have this memory support built in.One version, the Amulet, uses self-timed logic. Eliminating the clock saves powerand reduces RF interference, but makes it necessary to introduce hardware protectionfeatures, such as register locking, into the main processor itself so that contention be-tween different hardware processes can be managed. This is an interesting example ofprotection techniques typical of an operating system being recycled in mainline proces-sor design.4.3.3 Security ProcessorsSome modern smartcards are based on ARM processors, and the preceding remarksapply (though memory limitations mean that only basic hardware protection may beused). But the great majority of the microprocessor smartcards in the field still have 8-bit processors. Some of them have memory management routines that let certain ad-dresses be read only when passwords are entered into a register in the preceding fewinstructions. The goal is that the various principals with a stake in the card—perhaps acard manufacturer, an OEM, a network, and a bank—can all have their secrets on thecard and yet be protected from each other. This may be a matter of software; but somecards have small, hardwired access control matrices to enforce this protection.There are other kinds of specialized hardware security support for cryptography andaccess control. Some of the encryption devices used in banking to handle ATM PINshave an authorized state, which must be set (by two console passwords or a physicalkey) when PINs are to be printed. This enables a shift supervisor to control when thisjob is run. Similar devices are used by the military to distribute keys. We’ll discusscryptoprocessors in more detail in Chapter 14, “Physical Tamper Resistance.”4.3.4 Other ProcessorsSome research systems in the 1970s implemented very extensive security checking inthe hardware, from Multics to various capability systems. Some systems have a fenceaddress, a boundary in the hardware below which only the operating system has ac-cess. More recent work has looked at quality of service (QoS) issues, and for ways inwhich one can guarantee that no process will hog the CPU to the extent that otherprocesses are blocked. Such mechanisms are now starting to be introduced commer-cially (‘Quality of Service Technology is promised by Microsoft for ‘the Win2Ktimeframe’.) The interaction of such features with access control and protection gener-ally is one of the things to watch out for in the future.
Security Engineering: A Guide to Building Dependable Distributed Systems
654.4 What Goes WrongPopular operating systems such as Unix/Linux and Windows are very large and com-plex, so they have many bugs. They are used in a huge range of systems, so their fea-tures are tested daily by millions of users under very diverse of circumstances.Consequently, many of the bugs are found and reported. Thanks to the Net, knowledgespreads widely and rapidly. Thus, at any one time, there may be dozens of securityflaws that are known and for which attack scripts may be circulating on the Net. Untilrecently, this problem was limited. The banking industry used mainframes that ran lesswidely understood operating systems, while the military used custom “multilevel se-cure” operating systems, which were not available to outsiders at all. Nowadays, bothof these industries are being forced by cost pressures to adopt commodity operatingsystems, so the publication of attack scripts has the potential to undermine a greatrange of systems.The usual goal of an attacker is to get a normal account on the system and then be-come the system administrator, in order to take over the system completely. A surpris-ing number of operating system bugs allow the transition from user to root. Such flawscan be classified in a number of ways, such as by the type of programming error, bythe stage in the development process at which it was introduced, or by the level in thesystem at which things go wrong [493]. The failure might not even be in the technicalimplementation, but in the higher-level design. The user interface might induce peopleto mismanage access rights or do other stupid things that cause the access control to bebypassed (see Section 4.4.3 for some examples).In general, the higher in a system we build the protection mechanisms, the morecomplex they’ll be, the more other software they’ll rely on, and the closer they’ll be tothe error-prone mark 1 human being, thus, the less dependable they are likely to be.4.4.1 Smashing the StackMany, if not most, of the technical attacks on operating systems that are reported inComputer Emergency Response Team (CERT) bulletins and security mailing lists in-volve memory-overwriting attacks, colloquially known as “smashing the stack” (seeFigure 4.6).Programmers are often careless about checking the size of arguments. A classic ex-ample was a vulnerability in the Unix finger command. A widespread implementationof this would accept an argument of any length, although only 256 bytes had been allo-cated for this argument by the program. The result was that when an attacker used thecommand with a longer argument, the trailing bytes of the argument ended up beingexecuted by the CPU.The usual technique is to arrange for the trailing bytes of the argument to have alanding pad, a long space of no-operation (NOP) commands or other register com-mands that don’t change the control flow, and whose task is to catch the processor if itexecutes any of them. The landing pad delivers the processor to the attack code, whichwill do something like creating a root account with no password or starting a shell withadministrative privilege directly.Many of the vulnerabilities reported routinely by CERT and bugtraq are variants onthis theme. There is really no excuse for the problem to continue, as it has been wellknown for a generation. Most of the early 1960s time-sharing systems suffered from it,
Chapter 4: Access Controls
66and fixed it [349]. Penetration analysis efforts at the System Development Corporationin the early 1970s showed that the problem of “unexpected parameters” was still one ofthe most frequently used attack strategies [503]. Intel’s 80286 processor introducedexplicit parameter-checking instructions—verify read, verify write, and verifylength—in 1982, but they were avoided by most software designers to prevent archi-tecture dependencies. In 1988, large numbers of Unix computers were brought downsimultaneously by the “Internet worm,” which used the finger vulnerability just de-scribed, and thus brought memory-overwriting attacks to the notice of the mass media[724]. Yet programmers still don’t check the size of arguments, and holes continue tobe found. The attack isn’t even limited to networked computer systems: at least onesmartcard could be defeated by passing it a message longer than its programmer hadanticipated.
Figure 4.6 Stack Smashing Attack.A recent survey paper describes memory-overwriting attacks as the “attack of thedecade” [207].4.4.2 Other Technical AttacksAfter memory-overwriting attacks, race conditions are probably next. These are wherea transaction is carried out in two or more stages, and it is possible for someone to alterit after the stage that involves verifying access rights.For example, the Unix command to create a directory, mkdir, formerly worked intwo steps: the storage was allocated, then ownership was transferred to the user. Sincethese steps were separate, a user could initiate a mkdir in background; and if this com-pleted orly the first step before being suspended, a second process could be used toreplace the newly created directory with a link to the password file. Then the originalprocess would resume, and change ownership of the password file to the user. The /tmp directory, used for temporary files, can often be abused in this way; the trick is towait until an application run by a privileged user writes a file here, then change it to asymbolic link to another file somewhere else—which will be removed when the privi-leged user’s application tries to delete the temporary file.A wide variety of other bugs have enabled users to assume root status and take overthe system. For example, the PDP-10 TENEX operating system had the bug that theprogram address could overflow into the next bit of the process state word, which wasthe privilege-mode bit; this meant that a program overflow could put a program in su-
Security Engineering: A Guide to Building Dependable Distributed Systems
67pervisor state. In another example, some Unix implementations had the feature that if auser tried to execute the command su when the maximum number of files were open,then su was unable to open the password file, and responded by giving the user rootstatus.There have also been a number of bugs that allowed service denial attacks. For ex-ample, Multics had a global limit on the number of files that could be open at once, butno local limits. A user could exhaust this limit and lock the system so that not even theadministrator could log on [493]. And until the late 1990s, most implementations of theInternet protocols allocated a fixed amount of buffer space to process the SYN packetswith which TCP/IP connections are initiated. The result was SYN flooding attacks. Bysending a large number of SYN packets, an attacker could exhaust the available bufferspace and prevent the machine accepting any new connections. This is now fixed usingsyncookies, discussed in Chapter 18, in Part 2.4.4.3 User Interface FailuresOne of the earliest attacks to be devised was the Trojan Horse, a program that the ad-ministrator is invited to run and that will do some harm if he does so. People wouldwrite games that checked occasionally whether the player was the system administra-tor, and if so would create another administrator account with a known password.Another trick is to write a program that has the same name as a commonly usedsystem utility, such as the Is command which lists all the files in a Unix directory, anddesign it to abuse the administrator privilege (if any) before invoking the genuine util-ity. The next step is to complain to the administrator that something is wrong with thisdirectory. When the administrator enters the directory and types Is to see what’s there,the damage is done. The fix is simple: an administrator’s PATH variable (the list ofdirectories that will be searched for a suitably named program when a command is in-voked) shouldn’t contain ‘.’ (the symbol for the current directory). Recent Unix ver-sions are shipped with this as a default; but it’s still an unnecessary trap for theunwary.Perhaps the most serious example of user interface failure, in terms of the number ofsystems at risk, is in Windows NT. In this operating system, a user must be the systemadministrator to install anything. This might be useful, as a configuration option, toprevent staff in a bank branch from running games on their PCs at lunchtime, andpicking up viruses. However, most environments are much less controlled, and peopleneed to be able to install software to get their work done. In practice, this means thatmillions of people have administrator privileges who shouldn’t need them, and are vul-nerable to attacks in which malicious code simply pops up a box telling them to dosomething. Microsoft’s response to this has been the one-way trust mechanism alreadydiscussed, which makes it possible to configure systems so that people can administertheir own machines without having too much power to damage other IT resources inthe company. However, this requires some care to implement properly. It also providesno protection where applications such as Web servers must run as root, are visible tothe outside world, and contain software bugs that enable them to be taken over.Another example, which might be argued is an interface failure, comes from the useof active content of various kinds such as ActiveX controls. These can be a menacebecause users have no intuitively clear way of controlling them, and they can be usedto launch serious attacks. Even Java, for all its supposed security, has suffered a num-ber of attacks that exploited careless implementations [226]. However, many people
Chapter 4: Access Controls
68(and many companies) are unwilling to forgo the bells and whistles that active contentcan provide.4.4.4 Why So Many Things Go WrongWe’ve already mentioned the basic problems faced by operating system security de-signers: their products are huge and therefore buggy, and are tested by large numbersof users in parallel, some of whom will publicize their discoveries rather than reportingthem to the vendor. There are other structural problems, too.One of the more serious causes of failure is kernel bloat. Under Unix, all devicedrivers, filesystems, and so on must be in the kernel. The Windows 2000 kernel con-tains drivers for a large number of smartcards, card readers, and the like, many ofwhich were written by equipment vendors. So large quantities of code are trusted, inthat they are put inside the security perimeter. It can’t really be a good idea for soft-ware companies to enable so many of their suppliers to break their systems, whether onpurpose or accidentally. Some other systems, such as MVS, introduced mechanismsthat decrease the level of trust needed by many utilities. However, the means to do thisin the most common operating systems are few and relatively nonstandard.Even more seriously, application developers often make their programs run as root.This may be easier, as it avoids permission problems. It also often introduces horriblevulnerabilities where more limited privilege could have been used with only a modi-cum of thought and a minor redesign. There are many systems—such as 1pr / 1pd, theUnix lineprinter subsystem—that do not need to run as root but do anyway on mostsystems. This has also been a source of security failures in the past (e.g., getting theprinter to spool to the password file).Some applications need a certain amount of privilege. For example, mail deliveryagents must be able to deal with user mailboxes. But while a prudent designer wouldrestrict this privilege to a small part of the application, most agents are written so thatthe whole program needs to run as root. The classic example is sendmail, which has along history of serious security holes; but many other MTAs also have problems. Thegeneral effect is that a bug that ought to compromise only one person’s mail may endup giving root privilege to an outside attacker.Sometimes the cure is almost as bad as the disease. Some programmers avoid rootbloat and the difficulty of getting non-root software installed and working securely byleaving important shared data structures and resources accessible to all users. Manysystems store mail in a file per user in a world-writeable directory, which makes mailforgery easy. The Unix file utmp—the list of users logged in—is frequently used forsecurity checking of various kinds, but is also frequently world-writeable! This shouldhave been built as a service rather than a file, but fixing problems like these once theinitial design decisions have been made can be difficult.
Security Engineering: A Guide to Building Dependable Distributed Systems
694.4.5 RemediesSome classes of vulnerability can be fixed using automatic tools. Stack-overwritingattacks, for example, are largely due to the lack of proper bounds checking in C (thelanguage most commonly used to write operating systems). Various tools are availableon the Net for checking C programs for potential problems; there is even a compilerpatch called StackGuard, which puts a canary next to the return address on the stack.This can be a random 32-bit value chosen when the program is started, and checkedwhen a function is torn down. If the stack has been overwritten meanwhile, then withhigh probability the canary will change [207].But, in general, much more effort needs to be put into design, coding, and testing.Rather than overusing powerful tools such as setuid in Unix and administrator privi-lege in NT, designers should create groups with limited powers, and be clear aboutwhat the compromise of that group should mean for the rest of the system. Programsshould have only as much privilege as necessary: the principle of least privilege [662].Software should also be designed so that the default configuration, and in general,the easiest way of doing something, is safe. But, many systems are shipped with dan-gerous defaults.Finally, there’s a contrarian view, of which you should be aware, as it’s held bysome senior Microsoft people: that access control doesn’t matter. Computers are be-coming single-purpose or single-user devices. Single-purpose devices, such as Webservers that deliver a single service, don’t need much in the way of access control asthere’s nothing for operating system access controls to do; the job of separating usersfrom each other is best left to the application code. As for the PC on your desk, if allthe software on it comes from a single source, then again there’s no need for the oper-ating system to provide separation [588]. Not everyone agrees with this: the NSA viewis at the other extreme, with deep distrust of application-level security and heavy em-phasis on using the mechanisms of trusted operating systems [510]. But one way oranother, it’s remarkable how little effective use is made of the access control mecha-nisms shipped with modern operating systems.4.4.6 Environmental CreepI have pointed out repeatedly that many security failures result from environmentalchange undermining a security model. Mechanisms that were adequate in a restrictedenvironment often fail in a more general one.Access control mechanisms are no exception. Unix, for example, was originally de-signed as a “single-user Multics” (hence the name). It then became an operating systemto be used by a number of skilled and trustworthy people in a laboratory who weresharing a single machine. In this environment, the function of the security mechanismsis primarily to contain mistakes, to prevent one user’s typing errors or program crashesfrom deleting or overwriting another user’s files. The original security mechanismswere quite adequate for this purpose.But Unix security became a classic “success disaster.” Unix was repeatedly extendedwithout proper consideration being given to how the protection mechanisms alsoneeded to be extended. The Berkeley extensions (rsh, rhosts, etc.) were based on anextension from a single machine to a network of machines that were all on one LAN
Chapter 4: Access Controls
70and all under one management. Mechanisms such as rhosts were based on a tuple(username,hostname) rather than just a user name, and saw the beginning of the trans-fer of trust.The Internet mechanisms (telnet, ftp, DNS, SMTP), which grew out of Arpanet inthe 1970s, were written for mainframes on what was originally a secure WAN. Main-frames were autonomous, the network was outside the security protocols, and therewas no transfer of authorization. Remote authentication, which the Berkeley modelwas starting to make prudent, was simply not supported. The Sun contributions (NFS,NIS, RPC, etc.) were based on a workstation model of the universe, with a multipleLAN environment with distributed management, but still usually in a single organiza-tion. (A proper tutorial on topics such as DNS and NFS is beyond the scope of thisbook, but there is some more detailed background material in Chapter 18, “NetworkAttack and Defense,” Section 18.2.)Mixing all these different models of computation together has resulted in chaos.Some of their initial assumptions still apply partially, but none of them applies globallyany more. The Internet now has hundreds of millions of PCs and workstations, millionsof LANs, thousands of interconnected WANs, and managements that are not just inde-pendent but may be in conflict (including nation states and substate groups at war witheach other). Many workstations have no management at all.Users, instead of being trustworthy but occasionally incompetent, are now largelyincompetent—but some are both competent and hostile. Code used to be simplybuggy—but now there is a significant amount of malicious code out there. Attacks oncommunications networks used to be the purview of national intelligence agen-cies—now they can be done by script kiddies, a term used to refer to relatively un-skilled people who have downloaded attack tools from the Net and launched themwithout any real idea of how they work.Unix and Internet security gives us yet another example of a system that started outreasonably well designed but that was undermined by a changing environment.Win2K and its predecessors in the NT product series have more extensive protectionmechanisms than Unix, but have been around for much less time. Realistically, all wecan say is that the jury is still out.4.5 SummaryAccess control mechanisms operate at a number of levels in a system, from applica-tions down through the operating system to the hardware. Higher-level mechanismscan be more expressive, but also tend to be more vulnerable to attack, for a variety ofreasons ranging from intrinsic complexity to implementer skill levels. Most attacksinvolve the opportunistic exploitation of bugs; and software that is very large, verywidely used, or both (as with operating systems) is particularly likely to have securitybugs found and publicized. Operating systems are also vulnerable to environmentalchanges that undermine the assumptions used in their design.The main function of access control in computer operating systems is to limit thedamage that can be done by particular groups, users, and programs whether througherror or malice. The most important fielded examples are Unix and NT, which aresimilar in many respects, though NT is more expressive. Access control is also an im-portant part of the design of special-purpose hardware such as smartcards and other
Security Engineering: A Guide to Building Dependable Distributed Systems
71encryption devices. New techniques are being developed to cope with object-orientedsystems and mobile code. But implementation remains generally awful.The general concepts of access control from read, write, and execute permissions togroups and roles will crop up again and again. In some distributed systems, they maynot be immediately obvious, as the underlying mechanisms can be quite different. Anexample comes from public key infrastructures, which are a reimplementation of anold access control concept, the capability.Research ProblemsMost of the issues in access control were identified by the 1960s or early 1970s, andwere worked out on experimental systems such as Multics [687] and the CAP [804].Much of the research in access control systems since has involved reworking the basicthemes in new contexts, such as object-oriented systems and mobile code.A recent thread of research is how to combine access control with the admissioncontrol mechanisms used to provide quality of service guaranteed in multimedia oper-ating systems. Another topic is how to implement and manage access control effi-ciently in large complex systems, using techniques such as roles.Further ReadingThe best textbook to use for a more detailed introduction to access control issues isDieter Gollmann’s Computer Security [344]. A technical report from U.S. Navy Labsgives a useful reference to many of the flaws found in operating systems over the last30 years or so [493]. One of the earliest reports on the subject (and indeed on computersecurity in general) is by Willis Ware [791]. One of the most influential early papers isby Jerry Saltzer and Mike Schroeder [662]; Butler Lampson’s influential paper on theconfinement problem is at [488].The classic description of Unix security is in the paper by Fred Grampp and BobMorris [350]. The most comprehensive textbook on this subject is Simson Garfinkeland Gene Spafford’s Practical Unix and Internet Security [331]; the classic on the In-ternet side of things is Bill Cheswick and Steve Bellovin’s Firewalls and Internet Se-curity [94], with many examples of network attacks on Unix systems.The protection mechanisms of Windows NT4 are described briefly in Gollmann, butmuch more thoroughly in Karanjit Siyan’s reference book, Windows NT Server 4 [711].For Win2K, I’ve used the Microsoft online documentation; no doubt a number of text-books will appear very soon. There is a history of microprocessor architectures at [79],and a reference book for Java security written by its architect Li Gong [346].All these topics are fast-moving; the attacks that are making the headlines changesignificantly (at least in their details) from one year to the next. To keep up, you shouldnot just read textbooks, but follow the latest notices from CERT, and mailing lists suchas bugtraq.